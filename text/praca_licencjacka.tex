% Sprawdzić tekst pod kątem napisu TODO
\documentclass[declaration,shortabstract,masc]{iithesis}

\usepackage[utf8]{inputenc}
\newcommand{\cpp}{C\raisebox{0.5ex}{{\tiny\textbf{++}}}}

\polishtitle{Analiza teoretyczna i porównawcza\fmlinebreak efektywnej pamięciowo, wysoce wydajnej\fmlinebreak tablicy asocjacyjnej SILT\fmlinebreak (Small Index Large Table)}
\englishtitle{Theoretical and Comparative Analysis of\fmlinebreak Memory-Efficient, High-Performance\fmlinebreak Associative Array SILT\fmlinebreak (Small Index Large Table)}
\polishabstract{SILT (Small Index Large Table) jest efektywną pamięciowo, wysoce wydajną tablicą asocjacyjną. Stanowi alternatywę dla innych popularnych struktur danych opracowanych na potrzeby rozwiązania problemu przechowywania par klucz-wartość. Została utworzona z myślą o ograniczeniu i zbalansowaniu zużycia pamięci oraz czasu obliczeń. W swojej pracy chcę się skupić na analizie teoretycznej tej struktury danych oraz na porównaniu jej działania z dostępną w bibliotece standardowej języka \cpp\ funkcją \texttt{std::unordered\_map}. W ramach analizy opiszę konstrukcję tej struktury obejmującą trzy główne części składowe -- SortedStore, HashStore oraz LogStore, jak również metodę haszowania kukułczego, która jest w niej wykorzystywana. Zaimplementuję tę strukturę danych i zbadam empirycznie jej wydajność. Porównam ją z wynikami teoretycznymi i doświadczalnymi, przedstawionymi przez jej twórców.}
\englishabstract{\indent SILT (Small Index Large Table) is memory-effective high-performance associative array. It is an alternative for other popular data structures that solve key-value storage problem. It was developed for purpose of reducing and balancing memory usage and computation time. In my thesis I would like to focus on theoretical analysis of this data structure and comparison with \cpp\ standard library's function \texttt{std::unordered\_map}. As part of analysis I will describe its construction consisting of three main parts -- SortedStore, HashStore, LogStore and cuckoo hashing method. I will implement this structure and empirically examine its performance. I~will compare it with theoretical and experimental results, shown by its authors.}
\author{Paweł Guzewicz}
\advisor{dr hab. Marek Piotrów}
\transcriptnum{263664}
\advisorgen{dr. hab. Marka Piotrowa}
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}

\begin{document}
	\chapter{Wprowadzenie}
		\section{Przeznaczenie i zastosowanie}
			Small Index Large Table (SILT) to złożona struktura danych zaprojektowana z~myślą o efektywnej realizacji operacji słownikowych
			\begin{enumerate}
				\item
					Wstawiania: \texttt{insert(Key key, Value value)}
				\item
					Usuwania: \texttt{remove(Key key)}
				\item
					Pobrania wartości: \texttt{get\_value(Key key)}
			\end{enumerate}
			gdzie \texttt{Key} oraz \texttt{Value} oznaczają odpowiednio typ klucza i typ wartości.\\
			\indent W założeniu ma ona szybko obsługiwać powyższe operacje przy zrównoważonym, niedużym zużyciu pamięci. Struktura ta ma być bowiem wykorzystywana w~przypadku konieczności przechowywania dużej ilości danych. Podobnie jak w strukturach bazo-danowych, także tu, kluczowym czynnikiem jest czas dostępu do pamięci dyskowej. (Przyjmujemy dla celów analizy, że jest to pamięć flash, podobnie jak w oryginalnej pracy \cite{SILT}.) Tablica SILT jest zaprojektowana tak, aby oszczędnie korzystać z tejże pamięci. Znajduje swe zastosowanie np. przy przetwarzaniu dużych danych (Big data) jako wariant bazy typu NoSQL.
		\section{Koncepcje i cechy}
			Oczekujemy realizacji wymienionych operacji słownikowych w asymptotycznym czasie stałym. Oczywiście należy brać pod uwagę możliwość wykorzystania cache'u procesora, który zmniejsza czas dostępu do danych i jednocześnie długie czasy dostępu do pamięci zewnętrznej (pamięć flash lub dysk twardy), których chcemy uniknąć.\\
			\indent Uwzględniając możliwości i ograniczenia sprzętowe należy stworzyć strukturę danych dopasowaną możliwie najlepiej do podanych operacji. Nie jest to łatwe, gdy dysponujemy jednym rodzajem magazynu danych. Rozwiązaniem jest połączenie kilku różnych struktur w~jedną. W każdej z tych podstruktur nacisk kładziony jest na inny aspekt -- możliwość szybiego wykonywania operacji modyfikujących strukturę słownika (\texttt{insert(Key key, Value value)} lub \texttt{remove(Key key)}) bądź ograniczenie pamięci kosztem rezygnacji z tych operacji i ograniczenia interfejsu do pobierania wartości (\texttt{get\_value(Key key)}). W~wyniku otrzymujemy kompromisowe rozwiązanie, które okazuje się być bardzo wydajne.\\
			\indent Innym celem, który chcemy osiągnąć jest skalowalność przy ograniczonym zużyciu pamięci przypadającej na jeden klucz.
		\section{Ogólny schemat działania}
			SILT składa się z trzech podstruktur: LogStore, kilku egzemplarzy HashStore i~SortedStore, które są ze sobą powiązane.\\
			\indent Pierwsza z nich odpowiada za szybką obsługę operacji wstawiania i usuwania. Wykorzystuje ona znaną technikę dopisywania kolejnych elementów (par klucz-wartość) na końcu dziennika (logu) -- pliku w pamięci flash. Jest to wysoce wydajne rozwiązanie, lecz nie zapewnia możliwości wyszukiwania, gdyż klucze są umieszczone w pliku w kolejności wstawiania. Do tego celu LogStore w~pamięci RAM przechowuje tablicę z haszowaniem, opartą o metodę haszowania kukułczego, w której zapamiętane są pozycje (przesunięcie od początku pliku) par klucz-wartość w pliku dziennika.\\
			\indent Podstruktury drugiego rodzaju (HashStore'y) są skompresowaną wersją LogStore'ów. Nowa jednostka powstaje w wyniku konwersji przepełnionego LogStore'u. HashStore'y również zawierają tablice z haszowaniem. Pozbawione są jednak informacji o przesunięciu (klucze są sortowane według haszy), przez co efektywniej wykorzystują pamięć. Ich jedynym zadaniem jest obsługa operacji pobrania wartości, wobec czego mogą być strukturami tylko do odczytu. Podobnie jak w LogStore'rze wszystkie dane trzymane są w pamięci flash, a w pamięci RAM zostaje umieszczony filtr (okrojona tablica z haszowaniem), który wstępnie określa, czy dany klucz może znajdować się w tym magazynie (przy niskim odsetku fałszywych pozytywnych wskazań, z ang. \textit{false positives}).\\
			\indent W trzeciej podstrukturze (SortedStore) w pamięci flash trzymane są posortowane dane. Eliminuje to konieczność używania tablicy z haszowaniem do wyszukiwania pozycji w pliku. Przy takim podejściu potrzebowalibyśmy jednak czasu $O\left(\log n\right)$, używając wyszukiwania binarnego, na znalezienie naszej wartości. Również i tu możemy zastosować efektywniejsze rozwiązanie -- indeksowanie za pomocą drzew trie trzymanych w pamięci RAM.
	\chapter{Struktura danych Small~Index~Large~	Table}
		\section{LogStore}
			Pary klucz-wartość przechowywane w strukturze SILT mają pewnien stały, ustalony rozmiar. Może on jednak być dosyć duży, więc zostanie zapisany w pamięci flash. W pamięci RAM przechowujemy zaś tablicę z haszowaniem kukułczym (a dokładniej w pewnym jego wariancie -- haszowaniu kukułczym dla częściowych kluczy).\\
			\indent W podstawowej wersji haszowania kukułczego używamy tablicy kubełków (ustalonego rozmiaru) oraz dwóch funkcji haszujących $h_1$ i $h_2$. Dla danego klucza wyznaczają one dwie potencjalne lokalizacje (kubełki), w które można wstawić nowy klucz. Jeśli w którymś z kubełków jest wolne miejsce, to wstawiamy do tego niezapełnionego kubełka nasz klucz. W przeciwnym razie wstawiamy nowy klucz do jednego z kubełków mimo zapełnienia i wypychamy znajdujący się w nim klucz (można myśleć, że podrzucamy kukułcze jajo do gniazda). Następnie wypchnięty klucz przenosimy do jego alternatywnej lokalizacji (drugiego kubełka). To również może powodować konieczność wypchnięcia kolejnego klucza. Kontynuujemy proces wstawiania i wypychania aż do znalezienia wolnego kubełka lub do momentu, gdy przekroczymy maksymalną liczbę wypchnięć. Jeśli osiągniemy limit i nie udało nam się wstawić elementu, oznacza to, że tablica jest już prawie pełna. Wówczas należy ponownie shaszować elementy tablicy używając nowych funkcji haszujących. Może być też konieczne zwiększenie rozmiaru tablicy (używając techniki podwajania wielkości utrzymujemy zamortyzowany czas stały).\\
			\indent W naszym przypadku, z uwagi na potencjalnie duży rozmiar klucza, unikamy wykorzystywania go w całości. SILT używa 160-bitowych kluczy, które pochodzą z rozkładu jednostajnego i są wstępnie obliczane przy użyciu algorytmu SHA-1. Dzięki temu otrzymujemy stałą długość klucza. Aby jeszcze zmniejszyć rozmiar kluczy w tablicy z haszowaniem kukułczym stosujemy tzw. częściowe klucze lub odciski palca (z ang. \textit{fingerprints}).\\
			\indent Haszowanie kukułcze dla częściowych kluczy (z ang. \textit{partial-key cuckoo hashing}) \cite{PKCH} to zmodyfikowana wersja haszowania kukułczego. Zamiast zapamiętywać cały 160-bitowy klucz zapamiętujemy pewnien jego znacznik. To w oczywisty sposób uniemożliwia odtworzenie z niego klucza i tym samym powoduje problem w momencie konieczności obliczenia alternatywnego kubełka. Wystarczy więc wraz z danymi przechowywanymi w komórce tablicy związać informację o drugim kubełku. W LogStore'rze będziemy używali do tego celu $14$-bitowych znaczników, zatem kubełki w tablicy będą indeksowane liczbami od $0$ do $2^{14} - 1$. Łączny rozmiar pojedynczego wpisu w kubełku to 6 bajtów. Zawiera on 14 bitów znacznika, jeden bit określający rodzaj operacji ($0$ dla usuwania, $1$ dla wstawiania), jeden bit zajętości ($0$, gdy wolny oraz $1$, gdy zajęty) oraz czterobajtową wartość przesunięcia od początku pliku (z ang. \textit{offset}). Znaczniki odpowiadają funkcjom $h_1$ oraz $h_2$ zaaplikowanym do klucza. Aby sprawdzić czy dany wpis w tablicy dotyczy klucza, dla którego właśnie szukamy wartość, należy obliczyć dla niego znaczniki i sprawdzić czy w kubełku indeksowanym $h_1$ znajduje się znacznik $h_2$ i odwrotnie. Schematycznie (pomijając informacje zakodowane w dwóch dodatkowych bitach oraz głębokość kubełków) dane są związane relacją \texttt{hash\_table[h1] = (h2, offset)}. Autorzy pracy \cite{SILT} ustalili eksperymentalnie głębokość kubełków na $4$. Co daje łącznie $2^{16}$ wpisów w tablicy. Znaczniki obliczane są jako rozłączne fragmenty $14$-bitowe wybrane spośród najmłodszych bitów 160-bitowego klucza. Przyjmujemy również ograniczenie na liczbę iteracji wstawień i wypychań na $64$.\\
			\indent Operacje wstawiania i usuwania elementów z LogStore'u z punktu widzenia struktury są niemal identyczne. Różnią się jedynie zapisaniem informacji o rodzaju operacji, wobec czego analiza usuwania sprowadza się do analizy wstawiania.
		\section{HashStore}
			HashStore to kompaktowa wersja LogStore. W momencie, gdy osiągniemy zapełnienie LogStore jest konwertowany do HashStore. Konwersja polega na przepisaniu danych z dziennika (logu) do nowego pliku tak, aby były uporządkowane w kolejności haszy, a nie -- jak poprzednio -- w kolejności wstawienia. Dzięki temu możemy zmniejszyć liczbę koniecznych do zapamiętania informacji. Wystarczy we spisach tablicy pamiętać jedynie znaczniki, pomijając przesunięcia. Można je bowiem wyliczyć, korzystając z ich uporządkowania i ze stałego rozmiaru par klucz-wartość.
		\section{SortedStore}
		\section{Przepływ danych wewnątrz struktury}
		\section{Rozszerzenia}
			Struktura SILT może być rozszerzona tak, aby umożliwić równoległe przetwarzanie transakcji (w rozumieniu bazy danych). Dodatkowo można jeszcze bardziej amortyzować czas, który jest poświęcany na konwersję z jednego magazynu danych do drugiego stosując konwersję równolegle do obsługi zapytań.\\
			\indent Innym ważnym aspektem jest możliwość odtwarzania danych po awarii. Do tego celu wystarczy zapamiętywać w osobnym dzienniku w pamięci flash kolejne operacje zlecone do LogStore'u. Po awarii, aby odzyskać tablicę trzymaną w pamięci RAM, należy po kolei odtworzyć operacje zapisane w dzienniku. Dla pozostałych magazynów możemy pamiętać kopię informacji z pamięci RAM na dysku, gdyż są one strukturami tylko do odczytu.\\
			\indent W przypadku dużego obciążenia pamięci RAM można, kosztem czasu dostępu, usunąć z niej tablice indeksujące dla HashStore'ów i SortedStore'ów, pod warunkiem, że zostaną zapamiętane w pamięci flash. Dla SortedStore możliwe jest nawet kompletne pominięcie struktury drzew trie, ale wiąże się to z kosztownym przeszukiwaniem binarnym.\\
			\indent Jeśli chcielibyśmy wykorzystać strukturę SILT do przechowywania par klucz-wartość o zmiennej długości, to możemy użyć techniki przechowywania par (przesunięcie, fragment pary klucz-wartość), gdzie przesunięcie odnosi się do odrębnego pliku, w którym zapamiętane są właściwe dane.
	\chapter{Analiza teoretyczna}
		\section{Haszowanie kukułcze}
		\section{Fałszywe pozytywne wskazania}
		\section{Drzewa trie}
		\section{Koszt operacji słownikowych}
	\chapter{Analiza porównawcza}
		\section{Opis eksperymentu}
		\section{Wyniki}
	\chapter{Wnioski}
		\section{Teoretyczne własności}
		\section{Praktyczne osiągnięcia}
	\begin{thebibliography}{3}
		\bibitem{SILT} Hyeontaek Lim, Bin Fan, David G. Andersen, Michael Kaminsky - SILT: A Memory-Efficient, High-Performance Key-Value Store
		\bibitem{PKCH} Bin Fan, David G. Andersen, Michael Kaminsky, Michael D. Mitzenmacher - Cuckoo Filter: Practically Better Than Bloom
		\bibitem{CH} Rasmus Pagh, Flemming Friche Rodler - Cuckoo hashing
		\bibitem{CHwS} Adam Kirsch, Michael Mitzenmacher, Udi Wieder - More Robust Hashing: Cuckoo Hashing with a Stash
	\end{thebibliography}
\end{document}
